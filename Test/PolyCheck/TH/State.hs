{-# LANGUAGE TemplateHaskell #-}
module Test.PolyCheck.TH.State where

import Control.Arrow
import Data.Function
import Data.Functor
import Language.Haskell.TH
import Language.Haskell.TH.Syntax
import Language.Haskell.TH.Datatype
import qualified Data.Map.Strict as Map
import Data.Map.Strict (Map)

instance TypeSubstitution Dec where
  applySubstitution m = \case
    DataD ctx name [] kind cons derivs ->
      DataD ctx name [] kind (f <$> cons) derivs
    _ -> error "TypeSubstitution: only works for data declarations with no type variable"
    where
      f (NormalC name bts) = NormalC name $
        fmap (second $ applySubstitution m) bts
      f _ = error "TypeSubstitution: not a normal constructor"

  freeVariables = \case
    DataD _ _ [] _ cons _ -> cons >>= f
    _ -> error "TypeSubstitution: only works for data declarations with no type variable"
    where
      f (NormalC _ bts) = bts >>= freeVariables . snd
      f _ = error "TypeSubstitution: not a normal constructor"

data Emptiness = Empty Exp | NonEmpty Exp

emptyB :: Emptiness -> Bool
emptyB (Empty _) = True
emptyB _ = False

type Key = (Name, Name, [Type])

data State = State
  { freshName :: Int
  , funcName :: String
  , lastTV :: Name
  , decs :: [Dec]
  , infom :: Map Name DatatypeInfo
  , logm :: Map Key Dec
  , fillm :: Map Key Dec
  , tvOccur :: Map Name [Bool]
  , tvSP :: Map Name [Bool]
  , emptiness :: Map Name Name
  }

qStateInit :: Name -> String -> Q ()
qStateInit a func = qPutQ $ State
  { freshName = 0
  , funcName = func
  , lastTV = a
  , decs = []
  , infom = Map.empty
  , logm = Map.empty
  , fillm = Map.empty
  , tvOccur = Map.empty
  , tvSP = Map.empty
  , emptiness = Map.empty
  }

isLastTV :: Name -> Q Bool
isLastTV a = do
  Just s@State{lastTV} <- qGetQ
  pure $ a == lastTV

newUniqueName :: String -> Q Name
newUniqueName name = do
  Just s@State{freshName, funcName} <- qGetQ
  qPutQ $ s{freshName = freshName + 1}
  pure $ mkName $ name <> show freshName <> funcName

getDecs :: Q [Dec]
getDecs = do
  Just s@State{decs} <- qGetQ
  pure decs

putDecs :: [Dec] -> Q ()
putDecs d = do
  Just s@State{decs} <- qGetQ
  qPutQ $ s{decs = decs <> d}

getDatatypeInfo :: Name -> Q (Maybe DatatypeInfo)
getDatatypeInfo name =
  qGetQ <&> (>>= (Map.lookup name . infom))

-- | The new datatypes currently being generated by the log and residual
-- functions are not visible to 'reifyDatatype' yet. So it first uses
-- 'getDatatypeInfo' to lookup those types maintained by the global state.
reifyDT :: Name -> Q DatatypeInfo
reifyDT name = getDatatypeInfo name
  >>= maybe (reifyDatatype name) pure
  >>= resolveInfo
  where
    resolveInfo info = do
      let cons = info & datatypeCons
      cons' <- traverse resolveFields cons
      pure info{datatypeCons = cons'}
    resolveFields con = do
      let fields = con & constructorFields
      fields' <- traverse resolveTypeSynonyms fields
      pure con{constructorFields = fields'}

getLogDecs :: Q [Dec]
getLogDecs = do
  Just s@State{logm} <- qGetQ
  pure $ Map.elems logm

getLogDec :: Key -> Q (Maybe Dec)
getLogDec k = do
  Just s@State{logm} <- qGetQ
  pure $ Map.lookup k logm

getLogType :: Key -> Q (Maybe Type)
getLogType k = getLogDec k <&> (<&> (\(DataD _ name _ _ _ _) -> ConT name))

putLogDec :: Key -> Dec -> Q ()
putLogDec k dec = do
  Just s@State{logm} <- qGetQ
  qPutQ $ s{logm = Map.insert k dec logm}

mkLogTypeName :: Key -> Q Name
mkLogTypeName k@(_, typeName, _) = do
  logTypeName <- newUniqueName $ nameBase typeName <> "Log"
  putLogDec k $ DataD [] logTypeName [] Nothing [] []
  pure logTypeName

substLogDecs :: [Name] -> [Name] -> Q ()
substLogDecs vars datatypeNames = do
  Just s@State{logm} <- qGetQ
  let m = ConT <$> Map.fromList (zip vars datatypeNames)
  let logm' = applySubstitution m <$> logm
  let f dec@(DataD _ name _ _ _ _) = normalizeDec dec <&> (name,)
  infom' <- Map.fromList <$> traverse f (Map.elems logm')
  qPutQ $ s{infom = infom', logm = logm'}

getFillDecs :: Q [Dec]
getFillDecs = do
  Just s@State{fillm} <- qGetQ
  pure $ Map.elems fillm

getFillDec :: Key -> Q (Maybe Dec)
getFillDec k = do
  Just s@State{fillm} <- qGetQ
  pure $ Map.lookup k fillm

getFillName :: Key -> Q (Maybe Name)
getFillName k = getFillDec k <&> (<&> (\(FunD name _) -> name))

putFillDec :: Key -> Dec -> Q ()
putFillDec k v = do
  Just s@State{fillm} <- qGetQ
  qPutQ $ s{fillm = Map.insert k v fillm}

mkFillName :: Key -> Q Name
mkFillName k@(_, typeName, _) = do
  fillName <- newUniqueName $ "fill_" <> nameBase typeName
  putFillDec k $ FunD fillName []
  pure fillName

getTvOccur :: Name -> Q (Maybe [Bool])
getTvOccur k = do
  Just s@State{tvOccur} <- qGetQ
  pure $ Map.lookup k tvOccur

putTvOccur :: Name -> [Bool] -> Q ()
putTvOccur k v = do
  Just s@State{tvOccur} <- qGetQ
  qPutQ $ s{tvOccur = Map.insert k v tvOccur}

getTvSP :: Name -> Q (Maybe [Bool])
getTvSP k = do
  Just s@State{tvSP} <- qGetQ
  pure $ Map.lookup k tvSP

putTvSP :: Name -> [Bool] -> Q ()
putTvSP k v = do
  Just s@State{tvSP} <- qGetQ
  qPutQ $ s{tvSP = Map.insert k v tvSP}

getEmptiness :: Name -> Q (Maybe Name)
getEmptiness k = do
  Just s@State{emptiness} <- qGetQ
  pure $ Map.lookup k emptiness

putEmptiness :: Name -> Name -> Q ()
putEmptiness k v = do
  Just s@State{emptiness} <- qGetQ
  qPutQ $ s{emptiness = Map.insert k v emptiness}

deleteEmptiness :: Name -> Q ()
deleteEmptiness k = do
  Just s@State{emptiness} <- qGetQ
  qPutQ $ s{emptiness = Map.delete k emptiness}
